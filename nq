#!/bin/bash

set -e

VERSION="1.0.0"

# Colors
RED='\033[0;31m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
GREEN='\033[0;32m'
NC='\033[0m'

show_help() {
    cat << EOF
nq - Natural Language Network Query Tool

Usage: nq [OPTIONS] <natural language instruction>

OPTIONS:
    -y, --yes       Auto-execute without confirmation
    -d, --debug     Show debug output
    -h, --help      Show this help message
    -v, --version   Show version

EXAMPLES:
    nq check if google.com is reachable
    nq show my public ip
    nq -y lookup dns records for github.com

SETUP:
    export OPENAI_API_KEY="your-api-key"
    export ANTHROPIC_API_KEY="your-api-key"
    export GEMINI_API_KEY="your-api-key"
    export NQ_USE_BEDROCK=true  # for AWS Bedrock
EOF
}

get_system_prompt() {
    echo "You are a network debugging expert. Output ONLY a single shell command, nothing else. No explanations, no markdown, no alternatives, no notes. Just one executable command. Use tools like: dig, nslookup, ping, traceroute, nc, nmap, curl, ifconfig, netstat, ss, lsof, tcpdump, openssl. On macOS prefer: ifconfig over ip, netstat over ss. For ping always use -c flag to limit count (e.g. ping -c 4). Never output harmful commands. For IPv4 addresses use 'curl -4 ifconfig.me' or 'curl ipv4.icanhazip.com'. For IPv6 use 'curl -6 ifconfig.me'."
}

check_tool_exists() {
    local cmd="$1"
    local tool=$(echo "$cmd" | awk '{print $1}')
    
    if ! command -v "$tool" >/dev/null 2>&1; then
        echo -e "${YELLOW}Warning: '$tool' not found${NC}" >&2
        
        # Suggest installation
        if command -v brew >/dev/null 2>&1; then
            echo -e "${CYAN}Try: brew install $tool${NC}" >&2
        elif command -v apt >/dev/null 2>&1; then
            echo -e "${CYAN}Try: sudo apt install $tool${NC}" >&2
        elif command -v dnf >/dev/null 2>&1; then
            echo -e "${CYAN}Try: sudo dnf install $tool${NC}" >&2
        elif command -v yum >/dev/null 2>&1; then
            echo -e "${CYAN}Try: sudo yum install $tool${NC}" >&2
        elif command -v pacman >/dev/null 2>&1; then
            echo -e "${CYAN}Try: sudo pacman -S $tool${NC}" >&2
        elif command -v apk >/dev/null 2>&1; then
            echo -e "${CYAN}Try: sudo apk add $tool${NC}" >&2
        fi
        
        echo -n "Try to execute anyway? (y/N): "
        read -r confirm
        if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
            echo -e "${RED}Command not executed${NC}"
            exit 0
        fi
    fi
}

call_openai() {
    local query="$1"
    local system_prompt="$2"
    local temp_file="$3"
    
    local escaped_query=$(printf '%s' "$query" | sed 's/\\/\\\\/g; s/"/\\"/g')
    local escaped_system=$(printf '%s' "$system_prompt" | sed 's/\\/\\\\/g; s/"/\\"/g')
    
    local api_url="${OPENAI_BASE_URL:-https://api.openai.com/v1}/chat/completions"
    local model="${OPENAI_MODEL:-gpt-4o-mini}"
    
    cat > "$temp_file" << EOF
{
  "model": "$model",
  "messages": [
    {"role": "system", "content": "$escaped_system"},
    {"role": "user", "content": "$escaped_query"}
  ],
  "max_tokens": 150,
  "temperature": 0
}
EOF
    
    curl -s -X POST "$api_url" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d @"$temp_file"
}

call_anthropic() {
    local query="$1"
    local system_prompt="$2"
    local temp_file="$3"
    
    local escaped_query=$(printf '%s' "$query" | sed 's/\\/\\\\/g; s/"/\\"/g')
    local escaped_system=$(printf '%s' "$system_prompt" | sed 's/\\/\\\\/g; s/"/\\"/g')
    
    cat > "$temp_file" << EOF
{
  "model": "claude-3-5-haiku-latest",
  "max_tokens": 150,
  "system": "$escaped_system",
  "messages": [
    {"role": "user", "content": "$escaped_query"}
  ]
}
EOF
    
    curl -s -X POST "https://api.anthropic.com/v1/messages" \
        -H "Content-Type: application/json" \
        -H "x-api-key: $ANTHROPIC_API_KEY" \
        -H "anthropic-version: 2023-06-01" \
        -d @"$temp_file"
}

call_gemini() {
    local query="$1"
    local system_prompt="$2"
    local temp_file="$3"
    
    local escaped_query=$(printf '%s' "$query" | sed 's/\\/\\\\/g; s/"/\\"/g')
    local escaped_system=$(printf '%s' "$system_prompt" | sed 's/\\/\\\\/g; s/"/\\"/g')
    
    cat > "$temp_file" << EOF
{
  "contents": [{
    "parts": [{"text": "$escaped_system\n\n$escaped_query"}]
  }],
  "generationConfig": {
    "temperature": 0,
    "maxOutputTokens": 150
  }
}
EOF
    
    curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=$GEMINI_API_KEY" \
        -H "Content-Type: application/json" \
        -d @"$temp_file"
}

call_bedrock() {
    local query="$1"
    local system_prompt="$2"
    local temp_file="$3"
    
    if ! command -v aws >/dev/null 2>&1; then
        echo -e "${RED}Error: AWS CLI not found. Install it for Bedrock support.${NC}" >&2
        exit 1
    fi
    
    local model="${NQ_BEDROCK_MODEL:-amazon.nova-lite-v1:0}"
    [[ "$debug" == "true" ]] && echo -e "${CYAN}Using model: $model${NC}" >&2
    
    # Determine region based on model prefix
    local region="${AWS_REGION:-us-east-1}"
    if [[ "$model" == us.* ]]; then
        # Cross-region inference models use us-west-2
        region="us-west-2"
    fi
    [[ "$debug" == "true" ]] && echo -e "${CYAN}Using region: $region${NC}" >&2
    
    local escaped_query=$(printf '%s' "$query" | sed 's/\\/\\\\/g; s/"/\\"/g')
    local escaped_system=$(printf '%s' "$system_prompt" | sed 's/\\/\\\\/g; s/"/\\"/g')
    
    # Different request formats for different models
    if [[ "$model" == amazon.nova* ]]; then
        # Amazon Nova format
        cat > "$temp_file" << EOF
{
  "messages": [
    {"role": "user", "content": [{"text": "$escaped_system\n\n$escaped_query"}]}
  ],
  "inferenceConfig": {
    "max_new_tokens": 150,
    "temperature": 0
  }
}
EOF
    elif [[ "$model" == mistral.* ]]; then
        # Mistral format
        cat > "$temp_file" << EOF
{
  "prompt": "<s>[INST] $escaped_system\n\n$escaped_query [/INST]",
  "max_tokens": 150,
  "temperature": 0
}
EOF
    else
        # Anthropic format
        cat > "$temp_file" << EOF
{
  "anthropic_version": "bedrock-2023-05-31",
  "max_tokens": 150,
  "system": "$escaped_system",
  "messages": [
    {"role": "user", "content": "$escaped_query"}
  ]
}
EOF
    fi
    
    aws bedrock-runtime invoke-model \
        --region "$region" \
        --model-id "$model" \
        --body "fileb://$temp_file" \
        --cli-binary-format raw-in-base64-out \
        /tmp/bedrock_response.json 2>/dev/null && cat /tmp/bedrock_response.json && rm -f /tmp/bedrock_response.json
}

auto_execute=false
debug=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -y|--yes)
            auto_execute=true
            shift
            ;;
        -d|--debug)
            debug=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            echo "nq version $VERSION"
            exit 0
            ;;
        -*)
            echo -e "${RED}Unknown option: $1${NC}" >&2
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

if [[ $# -eq 0 ]]; then
    echo -e "${RED}Error: Please provide a natural language instruction${NC}" >&2
    echo "Use 'nq -h' for help" >&2
    exit 1
fi

query="$*"
system_prompt=$(get_system_prompt)

# Determine provider
provider=""
if [[ "$NQ_USE_BEDROCK" == "true" ]]; then
    provider="bedrock"
    echo -e "${CYAN}Using AWS Bedrock${NC}"
elif [[ -n "$OPENAI_API_KEY" ]]; then
    provider="openai"
    echo -e "${CYAN}Using OpenAI${NC}"
elif [[ -n "$ANTHROPIC_API_KEY" ]]; then
    provider="anthropic"
    echo -e "${CYAN}Using Anthropic${NC}"
elif [[ -n "$GEMINI_API_KEY" ]]; then
    provider="gemini"
    echo -e "${CYAN}Using Google Gemini${NC}"
else
    echo -e "${RED}Error: No API key found. Set OPENAI_API_KEY, ANTHROPIC_API_KEY, GEMINI_API_KEY, or NQ_USE_BEDROCK=true${NC}" >&2
    exit 1
fi

# Create temp file for request
temp_file=$(mktemp)
trap 'rm -f "$temp_file"' EXIT

# Call appropriate provider
case "$provider" in
    "openai")
        response=$(call_openai "$query" "$system_prompt" "$temp_file")
        command=$(echo "$response" | sed -n 's/.*"content": *"\([^"]*\)".*/\1/p' | head -1 | sed 's/\\n.*//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/\\u003c/</g' | sed 's/\\u003e/>/g' | sed 's/\\033\[[0-9;]*m//g')
        ;;
    "anthropic")
        response=$(call_anthropic "$query" "$system_prompt" "$temp_file")
        command=$(echo "$response" | sed -n 's/.*"text": *"\([^"]*\)".*/\1/p' | head -1 | sed 's/\\n.*//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/\\u003c/</g' | sed 's/\\u003e/>/g' | sed 's/\\033\[[0-9;]*m//g' | sed 's/\033\[[0-9;]*m//g')
        ;;
    "gemini")
        response=$(call_gemini "$query" "$system_prompt" "$temp_file")
        if echo "$response" | grep -q '"error"'; then
            error_msg=$(echo "$response" | sed -n 's/.*"message": *"\([^"]*\)".*/\1/p')
            echo -e "${RED}Gemini API Error: $error_msg${NC}" >&2
            exit 1
        fi
        command=$(echo "$response" | sed -n 's/.*"text": *"\([^"]*\)".*/\1/p' | head -1 | sed 's/\\n.*//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/\\u003c/</g' | sed 's/\\u003e/>/g' | sed 's/\\033\[[0-9;]*m//g' | sed 's/\033\[[0-9;]*m//g')
        ;;
    "bedrock")
        [[ "$debug" == "true" ]] && echo -e "${CYAN}Calling AWS Bedrock...${NC}" >&2
        response=$(call_bedrock "$query" "$system_prompt" "$temp_file")
        [[ "$debug" == "true" ]] && echo -e "${CYAN}Response received${NC}" >&2
        if echo "$response" | grep -q '"error"'; then
            error_msg=$(echo "$response" | sed -n 's/.*"message": *"\([^"]*\)".*/\1/p')
            echo -e "${RED}Bedrock API Error: $error_msg${NC}" >&2
            exit 1
        fi
        model="${NQ_BEDROCK_MODEL:-amazon.nova-lite-v1:0}"
        if [[ "$model" == amazon.nova* ]]; then
            raw_text=$(echo "$response" | grep -o '"text":"[^"]*"' | head -1 | sed 's/"text":"//' | sed 's/"$//')
            command=$(echo "$raw_text" | sed 's/```sh//g' | sed 's/```bash//g' | sed 's/```//g' | sed 's/\\n/ /g' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | tr -s ' ')
        elif [[ "$model" == mistral.* ]]; then
            raw_command=$(echo "$response" | sed -n 's/.*"outputs": *\[{"text": *"\([^"]*\)".*/\1/p' | head -1)
            command=$(echo "$raw_command" | sed 's/\\n.*//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/```sh//g' | sed 's/```bash//g' | sed 's/```//g' | sed 's/\\u003c/</g' | sed 's/\\u003e/>/g' | sed 's/ \\$//g' | sed 's/\\033\[[0-9;]*m//g' | sed 's/\033\[[0-9;]*m//g')
        else
            raw_command=$(echo "$response" | sed -n 's/.*"text": *"\([^"]*\)".*/\1/p' | head -1)
            command=$(echo "$raw_command" | sed 's/\\n.*//' | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | sed 's/```sh//g' | sed 's/```bash//g' | sed 's/```//g' | sed 's/\\u003c/</g' | sed 's/\\u003e/>/g' | sed 's/ \\$//g' | sed 's/\\033\[[0-9;]*m//g' | sed 's/\033\[[0-9;]*m//g')
        fi
        ;;
esac

if [[ -z "$command" ]]; then
    echo -e "${RED}Error: Failed to get response from API${NC}" >&2
    exit 1
fi

printf "${BLUE}Generated command: %s${NC}\n" "$command"

# Check if tool exists
check_tool_exists "$command"

if [[ "$auto_execute" == "false" ]]; then
    echo -n "Execute this command? (y/N): "
    read -r confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "${YELLOW}Command not executed${NC}"
        exit 0
    fi
fi

echo -e "${CYAN}Executing: $command${NC}"
if eval "$command"; then
    echo -e "${GREEN}Command completed successfully${NC}"
else
    echo -e "${RED}Command failed${NC}" >&2
    exit 1
fi